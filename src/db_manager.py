"""
Database management module for DuckDB operations.

This module encapsulates all DuckDB database operations including connection
management, query execution, and analytical function support. It provides
a safe interface for executing SQL queries generated by the coding agent.
"""

from pathlib import Path
from typing import Any, Dict, List, Optional

import duckdb

from config import settings


class DuckDBManager:
    """
    Encapsulates DuckDB connection and query execution with analytical function support.
    
    This class manages the DuckDB database connection and provides methods to:
    - Execute SQL queries safely (with validation)
    - Support analytical functions (aggregations, statistical functions)
    - Query table metadata
    - Handle connection lifecycle
    """

    def __init__(self, database_path: Optional[str] = None) -> None:
        """
        Initialize DuckDB connection and enable extensions.
        
        Args:
            database_path: Optional path to DuckDB database file.
                          If None, uses settings.duckdb_path.
                          Use ":memory:" for in-memory database.
                          
        Note:
            - Creates parent directories if database path is specified
            - Installs and loads the median extension for statistical functions
        """
        # Use provided path or fall back to settings
        db_path = database_path or settings.duckdb_path
        
        # Ensure parent directory exists when persisting to disk
        path_obj = Path(db_path)
        if str(db_path) != ":memory:" and path_obj.parent:
            path_obj.parent.mkdir(parents=True, exist_ok=True)
        
        # Connect to DuckDB (creates database if it doesn't exist)
        self.con = duckdb.connect(database=str(db_path), read_only=False)
        
        # Enable extensions for analytical functions
        # The median extension provides MEDIAN() function for statistical analysis
        # self.con.execute("INSTALL median;")
        # self.con.execute("LOAD median;")

    def load_tables(self, schemas: Dict[str, List[str]]) -> None:
        """
        Hook for schema tracking - tables are loaded via data_loader.
        
        This method is a placeholder for potential future functionality.
        Currently, tables are loaded directly in data_loader.py.
        
        Args:
            schemas: Dictionary mapping table names to column lists
        """
        _ = schemas

    def validate_query(self, sql: str) -> bool:
        """
        Basic validation: check if query is a SELECT statement.
        
        This is a safety measure to prevent destructive operations.
        Only SELECT and WITH (CTE) statements are allowed.
        
        Args:
            sql: SQL query string to validate
            
        Returns:
            True if query starts with SELECT or WITH, False otherwise
        """
        sql_clean = sql.strip().upper()
        # Allow CTEs (WITH ... SELECT) and SELECT statements
        return sql_clean.startswith("SELECT") or sql_clean.startswith("WITH")

    def validate_schema(self, sql: str) -> Dict[str, Any]:
        """
        Validate query against the database schema using EXPLAIN.
        
        This method attempts to plan the query without executing it.
        If the query references non-existent columns or tables, DuckDB will
        throw a Binder Error, which we capture to return precise feedback.
        
        Args:
            sql: SQL query to validate
            
        Returns:
            Dictionary with 'valid' (bool) and 'error' (str) if invalid
        """
        if not self.validate_query(sql):
            return {"valid": False, "error": "Query must be a SELECT statement."}
            
        try:
            # EXPLAIN verifies semantics (binder) without running the heavy query
            self.con.execute(f"EXPLAIN {sql}")
            return {"valid": True}
        except duckdb.BinderException as e:
            return {"valid": False, "error": f"Schema Error: {str(e)}"}
        except duckdb.CatalogException as e:
            return {"valid": False, "error": f"Schema Error: {str(e)}"}
        except duckdb.ParserException as e:
            return {"valid": False, "error": f"Syntax Error: {str(e)}"}
        except Exception as e:
            # Catch-all for other DuckDB errors
            return {"valid": False, "error": f"Validation Error: {str(e)}"}

    def query(self, sql: str) -> List[Dict[str, Any]]:
        """
        Execute a SQL query and return results as a list of dictionaries.
        
        This method:
        1. Validates the query is a SELECT statement
        2. Executes the query in DuckDB
        3. Converts results to a list of dictionaries (one per row)
        4. Handles errors gracefully
        
        Supports analytical functions:
        - Aggregations: COUNT, SUM, AVG, MIN, MAX
        - Statistical: MEDIAN (via extension)
        - Grouping: GROUP BY
        - Filtering: WHERE, HAVING
        - Date functions: DATE_TRUNC, EXTRACT, etc.
        
        Args:
            sql: SQL query string to execute
            
        Returns:
            List of dictionaries, where each dictionary represents a row
            with column names as keys.
            Example: [{"market": "US", "sessions": 1000}, ...]
            
        Raises:
            ValueError: If query is empty or not a SELECT statement
            RuntimeError: If query execution fails
        """
        # Validate query is not empty
        if not sql.strip():
            raise ValueError("Empty SQL query provided")
        
        # Validate query is a SELECT statement (safety check)
        if not self.validate_query(sql):
            raise ValueError(
                "Query must be a SELECT statement. "
                "Only read operations are allowed for safety."
            )
        
        try:
            # Execute query and fetch all results
            result = self.con.execute(sql).fetchall()
            
            # Get column names from query description
            if self.con.description:
                columns = [desc[0] for desc in self.con.description]
                # Convert rows to dictionaries with column names as keys
                return [dict(zip(columns, row)) for row in result]
            
            # Return empty list if no description (shouldn't happen with SELECT)
            return []
            
        except duckdb.Error as e:
            # DuckDB-specific errors
            raise RuntimeError(f"DuckDB query failed: {e}") from e
        except Exception as exc:  # noqa: BLE001
            # Catch-all for other exceptions
            raise RuntimeError(f"Query execution error: {exc}") from exc

    def get_table_info(self, table_name: str) -> Optional[Dict[str, Any]]:
        """
        Get information about a specific table.
        
        Args:
            table_name: Name of the table to describe
            
        Returns:
            Dictionary with table information, or None if table doesn't exist
        """
        try:
            result = self.query(f"DESCRIBE {table_name}")
            return {"columns": result} if result else None
        except Exception:
            return None

    def list_tables(self) -> List[str]:
        """
        List all tables in the database.
        
        Returns:
            List of table names in the database
        """
        try:
            result = self.query("SHOW TABLES")
            return [row["name"] for row in result] if result else []
        except Exception:
            return []

    def close(self) -> None:
        """
        Close the database connection.
        
        This should be called when the database is no longer needed
        to free up resources. The connection is automatically closed
        when the object is garbage collected, but explicit closing is recommended.
        """
        if self.con:
            self.con.close()
